/*  Copyright (C) 2004	    Grant Izmirlian
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.
 *
 *  Synopsis:
 */
#include<math.h>
#include<stdlib.h>
#include<stdio.h>
#include<R.h>
//
//MACROS
#define COMPH(xh,h,H,n,l) *H=0.0;for(l=1;l<n;l++) *(H+l)=*(H+l-1)+ *(h+l-1) * (*(xh+l) - *(xh+l-1))
#define hatX(x,xh,h,h_,n,l) l=0;while(*(xh+l)<=x && l<n) l++; h_ = *(h+l-1)
#define hHatX(x,xh,h,H,h_,H_,n,l) l=0;while(*(xh+l)<=x && l<n) l++; h_ = *(h+l-1); H_ = *(H+l-1) + h_ * (x-*(xh+l-1))
#define HIatW(W,xh,h,H,HI_,n,l) l=0;while(*(H+l)<=W && l<n) l++; HI_ = *(xh+l-1) + (W - *(H+l-1))/(*(h+l-1))
#define MIN(x,y) (x<=y ? x : y)
#define MAX(x,y) (x>=y ? x : y)
#define normut 8.20953615160139
//
//
typedef struct{
  long index;
  double time;
  long event;
  long arm;
} itea;
typedef itea iteaElt;
typedef itea *InTiEvAr;

typedef struct{
  double time;
  long risk;
  long event;
} tre;
typedef tre treElt;
typedef tre *TiRiEv;

int       CmprDbl(double *, double *);
int    (*cmprdbl)(double *, double *);
int  compInTiEvAr(InTiEvAr, InTiEvAr);
int          (*f)(InTiEvAr, InTiEvAr);
void    randfromh(long *pn, double *tcut, double *h, long *pncut, 
                  double *t);
void    randhcdtl(long *pn, double *tcut, double *h, long *pncut, double *tend,
	          double *tcutdA, double *hdA, long *pncutdA, double *tdA,
	          double *tcutdB, double *hdB, long *pncutdB, double *tdB,
                  double *tcutxA, double *hxA, long *pncutxA, double *tcutxB, 
		  double *hxB, long *pncutxB, long *gradual, long *code, double *t);
void       handle(long *pn, double *tlook,  double *u, double *t0, double *t1,
                  double *tc0, double *tc1, InTiEvAr YY, long *pntot);
void     kmdetail(InTiEvAr Yord, TiRiEv cp, TiRiEv cp0, TiRiEv cp1, long *pn, long *pndths);
void      commonx(double *x1,double *h1,long *pn1,double *x2,double *h2,long *pn2,
	          double *x,double *hh1,double *hh2,long *pn);
void     (*wtfun)(TiRiEv cp, long *pndths, double *par, double *val);
void      wlrstat(long *pndths, TiRiEv cp, TiRiEv cp1, double *wt, double *stat, 
	          double *var, double *eta);
void   grpseqbnds(long *dofu, long *nbnd, long *nsf, long *islast, long *pnthslook, 
                  double *palphatot, double *palpha, double *psimin, long *dlact, 
		  double *pInfTold, double *pInfTnew, double *px, double *py, 
		  double *ptmp, double *pintgrndx, double *pgqx, double *pgqw, 
		  long *pngqnodes, double *mu, double *pbold, double *pbnew);
double    qnormGI(double, double, double, long, long);
// add header for alternate weighting function below 'flemhar':
void      flemhar(TiRiEv cp, long *pndths, double *par, double *wt);

// add header for alternate spending function below 'obrien' and 'pocock':
double     obrien(double frac, double alphtot);

double     pocock(double frac, double alphtot);

void     printmat(double *pA, long nr, long nc, char *name);

// begin main
void    SimPwrGSD(long *argsizes,double *accru,double *accrat,double *pttlook,
		  double *palphatot,double *lrrf,double *bHay, double *ppar,
		  double *pgqx,double *pgqw,double *tcut0,double *h0,
	          double *tcut1,double *h1,double *tcutc0,double *hc0,
	          double *tcutc1,double *hc1,double *tcutd0A,double *hd0A,
	          double *tcutd0B,double *hd0B,double *tcutd1A,double *hd1A,
	          double *tcutd1B,double *hd1B,double *tcutx0A, double *hx0A,
	          double *tcutx0B, double *hx0B,double *tcutx1A,double *hx1A,
	          double *tcutx1B,double *hx1B,double *t0,double *t1,double *tc0,
	          double *tc1,double *td0A,double *td0B,double *td1A,double *td1B,
	          long *code,double *u, double *TT,long *delta,
	          long *z,double *time,long *nrisk,long *nevent,
	          double *time1,long *nrisk1,long *nevent1,double *pstatk,
	          double *pvark,long *pndthsk,double *pstat,double *pvar,
	          long *pndths,double *pinffrac,double *pbounds,double *palphavec,
	          long *pRejAcc,double *duration,double *pstatall)
{
  GetRNGstate();
  long *pn, *pntot, *pnthslook,*islast, *nbnd, *nsf;
  long *pnsim, *pnlook, *pnstat, *sided, *pngqnodes;
  long *pncut0, *pncut1, *pncutc0, *pncutc1;
  long *pncutd0A, *pncutd0B, *pncutd1A, *pncutd1B;
  long *pncutx0A, *pncutx0B, *pncutx1A, *pncutx1B;
  long *gradual, *dofu, *dlact;
  long ndbl, n, nlook, ncut0, ncut1, ncut;
  long ii, j, k, kacte, kactf, l;
  long ngqnodes, nsim, nstat, RejNull, AccNull;
  long ixxx, flag, idx;
  InTiEvAr Yord;
  TiRiEv cp, cp0, cp1;

  double *ptlook, *wt, *pInfTold, *pInfTnew, *par, *palpha;
  double *pbold, *pbnew, *px, *py, *ptmp, *pintgrndx, *statk;
  double *vark, *stat, *var, *etaold, *etanew, *psimin, *mu;
  double atotsv, wlrsgn, wlrZ, lrrf_, mu_;

  pnsim = argsizes;
  pnlook = argsizes + 1;
  pnstat = argsizes + 2;
  sided = argsizes + 3;
  pngqnodes = argsizes + 4;
  pncut0 = argsizes + 5;
  pncut1 = argsizes + 6;
  pncutc0 = argsizes + 7;
  pncutc1 = argsizes + 8;
  pncutd0A = argsizes + 9;
  pncutd0B = argsizes + 10;
  pncutd1A = argsizes + 11;
  pncutd1B = argsizes + 12;
  pncutx0A = argsizes + 13;
  pncutx0B = argsizes + 14;
  pncutx1A = argsizes + 15;
  pncutx1B = argsizes + 16;
  gradual = argsizes+17;
  nbnd = argsizes+18; // 18 & 19
  nsf = argsizes+20;  // 20 & 21
  dofu = argsizes+22;

  ngqnodes = *pngqnodes;
  nsim = *pnsim;
  nstat = *pnstat;
  nlook = *pnlook;
  ndbl = (long)(*accru)*(*accrat);
  ndbl = ndbl + (ndbl%2);
  n = ndbl/2;
  ncut0 = *pncut0;
  ncut1 = *pncut1;
  ncut = MAX(ncut0, ncut1);

  Yord = (InTiEvAr)malloc(ndbl*sizeof(iteaElt));
  cp = (TiRiEv)malloc(ndbl*sizeof(treElt));
  cp0 = (TiRiEv)malloc(ndbl*sizeof(treElt));
  cp1 = (TiRiEv)malloc(ndbl*sizeof(treElt));
  par = (double *)malloc(2*sizeof(double));
  wt = (double *)malloc(ndbl*sizeof(double));
  px = (double *)malloc(2*ngqnodes*sizeof(double));
  py = (double *)malloc(2*ngqnodes*sizeof(double));
  ptmp = (double *)malloc(2*ngqnodes*sizeof(double));
  pintgrndx = (double *)malloc(2*ngqnodes*sizeof(double));
  statk = (double *)malloc(sizeof(double));
  vark = (double *)malloc(sizeof(double));
  stat = (double *)malloc(sizeof(double));
  var = (double *)malloc(sizeof(double));
  etaold = (double *)malloc(sizeof(double));
  etanew = (double *)malloc(sizeof(double));
  ptlook = (double *)malloc(sizeof(double));
  pInfTold = (double *)malloc(sizeof(double));
  pInfTnew = (double *)malloc(sizeof(double));
  palpha = (double *)malloc(2*sizeof(double));
  pbold = (double *)malloc(2*sizeof(double));
  pbnew = (double *)malloc(2*sizeof(double));
  pnthslook = (long *)malloc(2*sizeof(long));
  islast = (long *)malloc(sizeof(long));
  pn = (long *)malloc(sizeof(long));
  pntot = (long *)malloc(sizeof(long));
  psimin = (double *)malloc(sizeof(double));
  dlact = (long *)malloc(2*sizeof(long));
  mu = (double *)malloc(sizeof(double));

  *pn = n;
  atotsv = *palphatot;
  *psimin = 6.416208e-17;

  //make choice of weighting function here:
  wtfun = &flemhar;

  for(l=0;l<2*ngqnodes;l++) {
    *(px+l) = 0.0;
    *(py+l) = 0.0;
    *(ptmp+l) = 0.0;
    *(pintgrndx+l) = 0.0;
  }
  *stat = 0.0;
  *var = 0.0;
  *statk = 0.0;
  *vark = 0.0;
  *palpha = 0.0;
  *(palpha+1) = 0.0;
  *pbnew = 0.0;
  *(pbnew+1) = 0.0;

  if(*sided==-1)
    for(l=0;l<ncut0;l++) *(lrrf + l) = *(lrrf + l)*(-1.0);

  //simulation loop begin
  for(ii=0;ii<nsim;ii++){

    //times of death due to lung cancer in arm 0 
    //generated conditional upon td0Ai and td0Bi.
    randhcdtl(pn, tcut0, h0, pncut0, pttlook+nlook-1, tcutd0A, hd0A, pncutd0A, 
	      td0A,tcutd0B, hd0B, pncutd0B, td0B, tcutx0A, hx0A, pncutx0A, 
	      tcutx0B, hx0B, pncutx0B, gradual, code, t0);

    //times of death due to lung cancer in arm 1 
    //generated conditional upon td1Ai and td1Bi.
    randhcdtl(pn, tcut1, h1, pncut1, pttlook+nlook-1, tcutd1A, hd1A, pncutd1A, 
	      td1A, tcutd1B, hd1B, pncutd1B, td1B, tcutx1A, hx1A, pncutx1A, 
              tcutx1B, hx1B, pncutx1B, gradual, code+n, t1);

    for(l=0;l<n;l++) *(code+n+l) = -1 * *(code+n+l);

    //censoring times due to death of other cause, arms 0 and 1.
    //censoring of this type as well as censoring due to 
    //alive at end of trial are handled outside in the function
    //'handle'.
    randfromh(pn, tcutc0, hc0, pncutc0, tc0);
    randfromh(pn, tcutc1, hc1, pncutc1, tc1);

    for(l=0;l<ndbl;l++) *(u+l) = *accru * unif_rand();

    for(j=0;j<nstat;j++){
      *par = *(ppar + j);
      *(par+1) = *(ppar + nstat + j);
      *ptlook = *(pttlook+nlook-1);
      handle(pn, ptlook, u, t0, t1, tc0, tc1, Yord, pntot);
      kmdetail(Yord, cp, cp0, cp1, pntot, pndths);
      (*wtfun)(cp, pndths, par, wt);
      wlrstat(pndths, cp, cp1, wt, stat, var, etanew);
       *(pstatall+nsim*j+ii) = *stat;
      if(ii==nsim-1){
        *(pstat+j) = *stat;
        *(pvar+j) = *var;

        for(l=0;l<(*pntot);l++){
	  idx = (Yord+l)->index;
	  *(TT+idx) = (Yord+l)->time;
	  *(delta+idx) = (Yord+l)->event;
	  *(z+idx) = (Yord+l)->arm;
        }
        for(l=0;l<(*pndths);l++) {
	  *(time+l) = (cp+l)->time;
	  *(nrisk+l) = (cp+l)->risk;
	  *(nevent+l) = (cp+l)->event;
	  *(time1+l) = (cp1+l)->time;
	  *(nrisk1+l) = (cp1+l)->risk;
	  *(nevent1+l) = (cp1+l)->event;
        }
      }

      k=0;                         
      kacte =0;
      kactf =0;
      RejNull=0;
      AccNull=0;
      *pInfTold=0.0;
      if(*nbnd==1) *pbold = 0.0;   
      if(*nbnd==2) *pbold = *bHay;
      if(*(nbnd+1)==1) *(pbold+1) = 0.0;
      if(*(nbnd+1)==2) *(pbold+1) = *bHay;

      *palphatot = atotsv;
      *etaold = 0.0;
      mu_ = 0.0;
      while(k<nlook && (1-RejNull) && (1-AccNull)){
	*islast = (k==(nlook-1));
        *ptlook = *(pttlook+k);
        *pnthslook = kacte+1;
	*(pnthslook+1) = kactf+1;
        handle(pn, ptlook, u, t0, t1, tc0, tc1, Yord, pntot);
        kmdetail(Yord, cp, cp0, cp1, pntot, pndthsk);
        (*wtfun)(cp, pndthsk, par, wt);
        wlrstat(pndthsk, cp, cp1, wt, statk, vark, etanew);
        wlrZ = *statk/pow(*vark, 0.5);
        *pInfTnew = *vark/(*var);
	hatX(*ptlook, tcut0, lrrf, lrrf_, ncut0, l);
	mu_ += lrrf_ * (*etanew - *etaold)/pow(*var,0.5);
	*mu = mu_;
	grpseqbnds(dofu, nbnd, nsf, islast, pnthslook, palphatot, palpha, psimin,
		   dlact, pInfTold, pInfTnew, px, py, ptmp, pintgrndx, pgqx, pgqw, 
		   pngqnodes, mu, pbold, pbnew);

	// test using *pbnew
	wlrsgn = (wlrZ >= 0.0 ? 1.0 : -1.0);
	if(*sided!=2)
	  RejNull = (wlrZ >= *pbnew)*(*sided==1) + (wlrZ <= (*pbnew)*(-1.0))*(*sided==-1);
	if(*sided==2)
	  RejNull = (wlrZ * wlrsgn >= *pbnew);
	if(*dofu==1){
	  if(*sided!=2)
	    AccNull = (wlrZ <= *(pbnew+1))*(*sided==1) + (wlrZ >= (*(pbnew+1))*(-1.0))*(*sided==-1);
	  if(*sided==2)
	    AccNull = (wlrZ * wlrsgn <= *(pbnew+1));
	}
	
//	printf("j:%d,k:%d, kact:%d, last:%d, RejNl:%d ", j,k,kact,*islast,RejNull);
//	printf("Z:%g, bnew:%g\, InfF:%g, fmin:%g\n",wlrZ,*pbnew*(-1),*pInfTnew,fmin);

	if(*dlact==1){
	  if(*nbnd==1) {
	    *(pbounds + nlook*j + k) = *pbnew;
	    *pbold = *pbnew;
	  }
          if(*nbnd==2){
	    if(k<nlook) {
	      *(pbounds + nlook*j + k) = *bHay;
	      *pbold = *bHay;
	      *palphatot = *palphatot - *palpha;
	    }
	    else *(pbounds + nlook*j + k) = *pbnew;
	  }
	  *(palphavec + nlook*j + k) = *palpha;
	  *pInfTold = *pInfTnew;
          kacte += 1;
	}
	else {
	  *(pbounds + nlook*j + k) = normut; 
	  *pbold = normut;
	  *(palphavec + nlook*j + k) = *psimin;
	  *pInfTold = *pInfTnew;
	}
	if(*dofu==1 && *(dlact+1)==1){
	  if(*(nbnd+1)==1) {
	    *(pbounds + nstat*nlook + nlook*j + k) = *(pbnew+1);
	    *(pbold+1) = *(pbnew+1);
	  }
	  if(*(nbnd+1)==2) {
	    if(k<nlook){
	      *(pbounds + nstat*nlook + nlook*j + k) = *bHay;
	      *(pbold+1) = *bHay;
	      *(palphatot+1) = *(palphatot+1) - *(palpha+1);
	    }
	    else *(pbounds + nstat*nlook + nlook*j + k) = *(pbnew+1);
	  }
	  *(palphavec + nstat*nlook + nlook*j + k) = *(palpha+1);
	  *pInfTold = *pInfTnew;
	  kactf += 1;
	}
	if(*dofu==1 && *(dlact+1)==0){
	  *(pbounds + nstat*nlook + nlook*j + k) = -normut;
	  *(pbold+1) = normut;
	  *(palphavec + nstat*nlook + nlook*j + k) = *psimin;
	  *pInfTold = *pInfTnew;
	}
	*(pinffrac + nlook*j + k) = *pInfTnew;
	k++;
	*etaold = *etanew;
      }

      *(pstatk+j) = *statk;
      *(pvark+j) = *vark;
      *(pRejAcc + nsim*j + ii) = RejNull;
      *(pRejAcc + nsim*nstat + nsim*j + ii) = AccNull;
      *(duration + nsim*j + ii) = *ptlook;
    } //different stats loop end
  }
  //simulation loop end

  PutRNGstate();

  free(Yord);
  free(cp);
  free(cp0);
  free(cp1);
  free(par);
  free(wt);
  free(px);
  free(py);
  free(ptmp);
  free(pintgrndx);
  free(statk);
  free(vark);
  free(stat);
  free(var);
  free(etaold);
  free(etanew);
  free(ptlook);
  free(pInfTold);
  free(pInfTnew);
  free(palpha);
  free(pbold);
  free(pbnew);
  free(pnthslook);
  free(islast);
  free(pn);
  free(pntot);
  free(psimin);
  free(dlact);
  free(mu);
}

void randfromh(long *pn, double *tcut, double *h, long *pncut, double *t)
{
  long n,ncut,i,l;
  double u,X,HI_;
  double *H;
  // simulates variates from a peicewise exponential distribution.
  //
  // arguments
  //
  //    pn: *long;   number of simulations desired
  // pncut: *long;   length of vector specifications for changepoints and hazards
  //  tcut: *double; vector of left-hand endpoints of constant hazards interval; 
  //                           last right-hand endpoint (not specified) is infinity.
  //     h: *double; vector of hazard function values.
  //     t: *double; vector of length *pn containing the answer.  Must be allocated 
  //                           in calling routine.

  n = *pn;
  ncut = *pncut;
  H = (double *)malloc(ncut*sizeof(double));

  COMPH(tcut,h,H,ncut,l);

  for(i=0;i<n;i++){

    u = unif_rand();
    X = -log(u);

    HIatW(X,tcut,h,H,HI_,ncut,l);

    *(t+i) = HI_;
  }
  free(H);
}

void randhcdtl(long *pn, double *tcut, double *h, long *pncut, double *tend,
	       double *tcutdA, double *hdA, long *pncutdA, double *tdA,
	       double *tcutdB, double *hdB, long *pncutdB, double *tdB,
               double *tcutxA, double *hxA, long *pncutxA, double *tcutxB, 
	       double *hxB, long *pncutxB, long *gradual, long *code, double *t)
{
  long n,ncut,ncutdA,ncutdB,ncutxA,ncutxB,nncutxA,nncutxB,ncutx,i,l,cd;
  long *pnncutxA,*pnncutxB;
  double tdAi, tdBi, td, u,X,htd,Htd,hx_td,Hx_td,HI_,htd_,Htd_;
  double hdAtend,HdAtend,hdBtend,HdBtend,pi;
  double *H,*HdA,*HdB,*HxA,*HxB,*tcutx,*hx,*Hx;
  double *ttcutxA,*hh_A,*HH_A,*hhxA,*HHxA,*ttcutxB,*hh_B,*HH_B,*hhxB,*HHxB;

  // Specialized code.  The conditional hazard function (dropping dependance on 
  // trial arm) is:
  //
  // gamma(x, tdA, tdB) = I(x <= tdA /\ tdB) h(x) + I(tdA < x /\ tdB) h_xA(x) 
  //                                              + I(tdB < x /\ tdA) h_xB(x)
  // The cummulative hazard becomes:
  //
  // Gamma(x, tdA, tdB) =   I(x <= tdA/\ tdB) H(x) 
  //                      + I(tdA < x /\ tdB)(H_xA(x) - H_xA(tdA) + H(tdA))
  //                      + I(tdB < x /\ tdA)(H_xB(x) - H_xB(tdB) + H(tdB))
  //
  // To simulate a variate, conditional upon 'tdA' and 'tdB', that has this 
  // cumulative hazard function, this program starts with a unit exponential, 'X', 
  // and finds the inverse of the above 'Gamma' at 'X'.
  // This is done by (i)   find 'td' = 'tdA' /\ 'tdB' the minimum of 'tdA' and 'tdB'.
  //                 (ii)  find 'H(td)' and compare it to 'X'.
  //                       If 'H(td)' is larger than 'X' then find 'T' such that 
  //                       'H(T)' = 'X' and output 'T'
  //                       If 'H(td)' is less than 'X' then let 'DX' = 'X' - 'H(td)'.
  //                 (iii) let 'DX' = 'DX' + 'H_xL(td)'
  //                 (iv)  Find 'T' such that 'H_xL(T)' = 'DX' . 
  //                       In the above, 'L' = 'A' if td = tdA, 'L' = 'B' if td = tdB.  
  //                 (v)   Output T
  //                                                                
  //times to leave for reason A
  randfromh(pn, tcutdA, hdA, pncutdA, tdA);

  //times to leave group 0 for reason B
  randfromh(pn, tcutdB, hdB, pncutdB, tdB);

  n = *pn;
  ncut = *pncut;
  ncutdA = *pncutdA;
  ncutdB = *pncutdB;
  ncutxA = *pncutxA;
  ncutxB = *pncutxB;
  nncutxA = MAX(ncut,ncutxA);
  nncutxB = MAX(ncut,ncutxB);
  ncutx = MAX(nncutxA,nncutxB);

  H = (double *)malloc(ncut*sizeof(double));
  HxA = (double *)malloc(ncutxA*sizeof(double));
  HxB = (double *)malloc(ncutxB*sizeof(double));
  if(*gradual == 1){
    HdA = (double *)malloc(ncutdA*sizeof(double));
    HdB = (double *)malloc(ncutdB*sizeof(double));
    ttcutxA = (double *)malloc(nncutxA*sizeof(double));
    hh_A = (double *)malloc(nncutxA*sizeof(double));
    HH_A = (double *)malloc(nncutxA*sizeof(double));
    hhxA = (double *)malloc(nncutxA*sizeof(double));
    HHxA = (double *)malloc(nncutxA*sizeof(double));
    ttcutxB = (double *)malloc(nncutxB*sizeof(double));
    hh_B = (double *)malloc(nncutxB*sizeof(double));
    HH_B = (double *)malloc(nncutxB*sizeof(double));
    hhxB = (double *)malloc(nncutxB*sizeof(double));
    HHxB = (double *)malloc(nncutxB*sizeof(double));
    tcutx = (double *)malloc(ncutx*sizeof(double));
    hx = (double *)malloc(ncutx*sizeof(double));
    Hx = (double *)malloc(ncutx*sizeof(double));
    pnncutxA = (long *)malloc(sizeof(long));
    pnncutxB = (long *)malloc(sizeof(long));
  }

  COMPH(tcut,h,H,ncut,l);
  COMPH(tcutxA,hxA,HxA,ncutxA,l);
  COMPH(tcutxB,hxB,HxB,ncutxB,l);

  if(*gradual == 1){
    commonx(tcut,h,pncut,tcutxA,hxA,pncutxA,ttcutxA,hh_A,hhxA,pnncutxA);
    nncutxA = *pnncutxA;
    commonx(tcut,h,pncut,tcutxB,hxB,pncutxB,ttcutxB,hh_B,hhxB,pnncutxB);
    nncutxB = *pnncutxB;

    COMPH(tcutdA,hdA,HdA,ncutdA,l);
    COMPH(tcutdB,hdB,HdB,ncutdB,l);
    COMPH(ttcutxA,hh_A,HH_A,nncutxA,l);
    COMPH(ttcutxA,hhxA,HHxA,nncutxA,l);
    COMPH(ttcutxB,hh_B,HH_B,nncutxB,l);
    COMPH(ttcutxB,hhxB,HHxB,nncutxB,l);

    hHatX(*tend,tcutdA,hdA,HdA,hdAtend,HdAtend,ncutdA,l);
    hHatX(*tend,tcutdB,hdB,HdB,hdBtend,HdBtend,ncutdB,l);
  }

  for(i=0;i<n;i++){
    *(code + i) = 0;
    tdAi = *(tdA + i);
    tdBi = *(tdB + i);
    if(tdAi<=tdBi){
      td = tdAi;
      if(*gradual == 1){
        hHatX(td,tcutdA,hdA,HdA,htd_,Htd_,ncutdA,l);
	pi = 1.0;
	if(td <= *tend) pi = Htd_/HdAtend;
        for(l=0;l<nncutxA;l++) {
	  *(tcutx+l) = *(ttcutxA+l);
	  *(hx+l) = pi* (*(hh_A+l)) + (1.0-pi)* (*(hhxA+l));
	  *(Hx+l) = pi* (*(HH_A+l)) + (1.0-pi)* (*(HHxA+l));
	  ncutx = nncutxA;
        }
      }
      else{
	tcutx = tcutxA;
	hx = hxA;
	Hx = HxA;
	ncutx = *pncutxA;
      }
      cd = 1;
    }
    if(tdAi>tdBi){
      td = tdBi;
      if(*gradual == 1){
        hHatX(td,tcutdB,hdB,HdB,htd_,Htd_,ncutdB,l);
	pi = 1.0;
        if(td <= *tend) pi = Htd_/HdBtend;
        for(l=0;l<nncutxB;l++) {
	  *(tcutx+l) = *(ttcutxB+l);
	  *(hx+l) = pi* (*(hh_B+l)) + (1.0-pi)* (*(hhxB+l));
	  *(Hx+l) = pi* (*(HH_B+l)) + (1.0-pi)* (*(HHxB+l));
	  ncutx = nncutxB;
	}
      }
      else{
	tcutx = tcutxB;
	hx = hxB;
	Hx = HxB;
	ncutx = *pncutxB;
      }
      cd = 2;
    }

    hHatX(td,tcut,h,H,htd,Htd,ncut,l);
    hHatX(td,tcutx,hx,Hx,hx_td,Hx_td,ncutx,l);
    u = unif_rand();
    X = -log(u);
    if(Htd >= X){
      HIatW(X,tcut,h,H,HI_,ncut,l);
      *(t+i) = HI_;
    }
    if(Htd < X){
      *(code + i) = cd;
      X = X - Htd + Hx_td;
      HIatW(X,tcutx,hx,Hx,HI_,ncutx,l);
      *(t+i) = HI_;
    }
  }
  free(H);
  free(HxA);
  free(HxB);
  if(*gradual == 1){
    free(HdA);
    free(HdB);
    free(ttcutxA);
    free(hh_A);
    free(HH_A);
    free(hhxA);
    free(HHxA);
    free(ttcutxB);
    free(hh_B);
    free(HH_B);
    free(hhxB);
    free(HHxB);
    free(tcutx);
    free(hx);
    free(Hx);
    free(pnncutxA);
    free(pnncutxB);
  }
}

void handle(long *pn, double *tlook, double *u, double *t0, double *t1, double *tc0,
            double *tc1, InTiEvAr YY, long *pntot)
{
  long n, n0, n1, ntot, i, j;
  double tout, tmpp;
  n = *pn;

  j=0;
  for(i=0;i<n;i++){
    tout = (*tlook - *(u+i) > 0.0 ? *tlook - *(u+i) : 0.0);
    if(*(u+i)<*tlook){
      tmpp = (*(tc0+i) < tout ? *(tc0+i) : tout);
      (YY+j)->index = j;
      (YY+j)->time = (*(t0+i) <= tmpp ? *(t0+i) : tmpp);
      (YY+j)->event = ((YY+j)->time==*(t0+i) ? 1 : 0);
      (YY+j)->arm = 0;
      j++;
    }
  }
  n0 = j;
  j=0;
  for(i=0;i<n;i++){
    tout = (*tlook - *(u+n+i) > 0.0 ? *tlook - *(u+n+i) : 0.0);
    if(*(u+n+i)<*tlook){
      tmpp = (*(tc1+i) < tout ? *(tc1+i) : tout);
      (YY+n0+j)->index = n0 + j;
      (YY+n0+j)->time = (*(t1+i) <= tmpp ? *(t1+i) : tmpp);
      (YY+n0+j)->event = ((YY+n0+j)->time==*(t1+i) ? 1 : 0);
      (YY+n0+j)->arm = 1;
      j++;
    }
  }
  n1 = j;
  ntot = n0+n1;
  *pntot = ntot;
}

void kmdetail(InTiEvAr Yord, TiRiEv cp, TiRiEv cp0, TiRiEv cp1, long *pn, long *pndths)
{
  long n,i,l,ndths,isev,dr,dr0,dr1,*ri,*ev,*ri0,*ev0,*ri1,*ev1;
  double yhold,*ti;

  n = *pn;
  f = &compInTiEvAr;
  qsort(Yord, n, sizeof(iteaElt), f);

  ti = (double *)malloc(n*sizeof(double));
  ri = (long *)malloc(n*sizeof(long));
  ri0 = (long *)malloc(n*sizeof(long));
  ri1 = (long *)malloc(n*sizeof(long));
  ev = (long *)malloc(n*sizeof(long));
  ev0 = (long *)malloc(n*sizeof(long));
  ev1 = (long *)malloc(n*sizeof(long));

  i=n-1;
  l=0;
  dr = 0;
  dr0 = 0;
  dr1 = 0;
  isev = 0;
  while(i>=0){
    *(ti+l) = (Yord+i)->time;
    *(ev+l) = 0;
    *(ev1+l)= 0;
    *(ri+l) = 0;
    *(ri1+l)= 0;
    yhold = *(ti+l);
    while((Yord+i)->time == yhold){
      isev = isev || 1*((Yord+i)->event > 0);
      *(ev+l) += (Yord+i)->event;
      *(ev0+l) += (1-(Yord+i)->arm) * (Yord+i)->event;
      *(ev1+l) += ((Yord+i)->arm) * (Yord+i)->event;
      dr++;
      dr0 += (1-(Yord+i)->arm);
      dr1 += (Yord+i)->arm;
      i--;
    }
    if(isev){
      *(ri+l) += dr;
      *(ri0+l) += dr0;
      *(ri1+l) += dr1;
      isev = 0;
      l++;
    }
  }
  ndths = l;
  for (l=0;l<ndths;l++){
    (cp+l)->time = *(ti+ndths-1-l);
    (cp+l)->risk = *(ri+ndths-1-l);
    (cp+l)->event = *(ev+ndths-1-l);
    (cp0+l)->time = *(ti+ndths-1-l);
    (cp0+l)->risk = *(ri0+ndths-1-l);
    (cp0+l)->event = *(ev0+ndths-1-l);
    (cp1+l)->time = *(ti+ndths-1-l);
    (cp1+l)->risk = *(ri1+ndths-1-l);
    (cp1+l)->event = *(ev1+ndths-1-l);
  }
  *pndths = ndths;
  free(ti);
  free(ri);
  free(ri0);
  free(ri1);
  free(ev);
  free(ev0);
  free(ev1);
}

void commonx(double *x1,double *h1,long *pn1,double *x2,double *h2,long *pn2,
	     double *x,double *hh1,double *hh2,long *pn)
{
  long l,j,n1,n2,n,nx;
  double yold,ynew,h1_,h2_;
  double *y;
  n1 = *pn1;
  n2 = *pn2;
  n=n1+n2;
  y = (double *)malloc(n*sizeof(double));
  for(l=0;l<n1;l++) *(y+l) = *(x1+l);
  for(l=0;l<n2;l++) *(y+n1+l) = *(x2+l);
  cmprdbl = &CmprDbl;
  qsort(y, n, sizeof(double), cmprdbl);
  j=1;
  yold = *y;
  *x = yold;
  for(l=1;l<n;l++){
    ynew = *(y+l);
    if(ynew!=yold) {
      *(x+j) = ynew;
      j++;
    }
    yold = ynew;
  }
  nx = j;
  for(j=0;j<nx;j++){
    hatX(*(x+j),x1,h1,h1_,n1,l);
    hatX(*(x+j),x2,h2,h2_,n2,l);
    *(hh1+j) = h1_;
    *(hh2+j) = h2_;
  }
  *pn = nx;  
  free(y);
}

int CmprDbl(double *x, double *y)
{
  return(1*(*x > *y) - 1*(*x < *y));
}

int compInTiEvAr(InTiEvAr x, InTiEvAr y)
{
  return (1*(x->time > y->time) - 1*(x->time < y->time));
}

void wpystat(long *pndths, TiRiEv cp0, TiRiEv cp1, double *wt, double *stat,
	     double *var)
void wlrstat(long *pndths, TiRiEv cp, TiRiEv cp1, double *wt, double *stat, 
	     double *var, double *eta)
{
  long ndths,i;
  double xev, xev1, xri, xri1, q, e, stat_, d_eta_, eta_, var_;
  ndths = *pndths;
  stat_ = 0.0;
  eta_ = 0.0;
  var_ = 0.0;
  for(i=0;i<ndths;i++){
    xev = (double) (cp+i)->event;
    xev1 = (double) (cp1+i)->event;
    xri = (double) (cp+i)->risk;
    xri1 = (double) (cp1+i)->risk;
    e = xri1/xri;
    q = *(wt+i);
    stat_ += q * (xev1 - e * xev);
    d_eta_ = q * e * (1.0 - e) * xev;
    eta_ += d_eta_;
    var_ += q * d_eta_;
  }
  *stat = stat_;
  *var = var_;
  *eta = eta_;
}

// Weighting Functions for Log-Rank Statistics:
//1.  Flemming Harington "G-rho,gamma" class:
void flemhar(TiRiEv cp, long *pndths, double *par, double *wt)
{
  double s,xev,xri;
  long i;
  s = 1.0;
  for (i=0;i<(*pndths);i++){
    xev = (double) (cp+i)->event;
    xri = (double) (cp+i)->risk;
    s = s * (1.0-xev/xri);
    *(wt+i)=pow(s,*par)*pow(1.0-s,*(par+1));
  }
}
// add definition for alternate weighting function here...
// don't forget to make corresponding changes in this program and the
// R function interface to expand the menu of choices, and don't forget
// to add include the corresponding function prototype declaration above.

